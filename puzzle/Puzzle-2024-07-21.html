<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <title>Puzzle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    body {
      height: 100vh;
      margin: 0;
      display: flex;
      flex-direction: column;
    }

    #canvas-holder {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: .5em;
    }

    #canvas {
      /* height: calc(100% - 1em); */
      height: 100%;
      border: 1px solid black;
    }

    .controller {
      width: 100%;
      display: flex;
      align-items: center;
    }

    #steps {
      width: 30vw;
      font-size: 2em;
      text-align: center;
      margin: 0;
    }

    #previous,
    #next {
      font-size: 2em;
      flex-grow: 1;
      height: 3em;
      color: white;
    }

    #previous[disabled],
    #next[disabled] {
      background-color: gray;
    }

    #previous {
      background-color: red;
    }

    #next {
      background-color: green;
    }

    @media screen and (max-width: 620px) {
      #canvas {
        width: 100%;
        height: auto;
        border: 1px solid black;
      }
    }
  </style>
</head>

<body>
  <div id="canvas-holder">
    <canvas id="canvas" width="600" height="600"></canvas>
  </div>
  <div class="controller">
    <button id="previous" onclick="onPreviousClicked()">&lt;</button>
    <p id="steps"></p>
    <button id="next" onclick="onNextClicked()">&gt;</button>
  </div>
  <script>
    const canvasEl = document.getElementById("canvas")
    const canvas = canvasEl.getContext("2d")
    const previousEl = document.getElementById("previous")
    const nextEl = document.getElementById("next")
    const stepsEl = document.getElementById("steps")
    let blocks = [
      {
        p: [0, 1],
        h: 1,
        v: 2,
      },
      {
        p: [1, 0],
        h: 1,
        v: 3,
      },
      {
        p: [3, 0],
        h: 1,
        v: 2,
      },
      {
        p: [4, 0],
        h: 2,
        v: 1,
      },
      {
        p: [4, 1],
        h: 1,
        v: 3,
      },
      {
        p: [0, 3],
        h: 2,
        v: 1,
      },
      {
        p: [2, 3],
        h: 1,
        v: 2,
      },
      {
        p: [0, 4],
        h: 1,
        v: 2,
      },
      {
        p: [1, 5],
        h: 2,
        v: 1,
      },
      {
        p: [3, 4],
        h: 2,
        v: 1,
      },
      {
        p: [5, 4],
        h: 1,
        v: 2,
      },
    ]
    let key = {
      p: [2, 2],
      h: 2,
      v: 1,
    }
    const operations = [
      { b: 10, v: -2 },
      { b: 8, h: 3 },
      { b: 6, v: 1 },
      { b: 5, h: 2 },
      { b: 1, v: 3 },
      { b: 0, v: -1 },
      { h: -2 },
      { b: 2, v: 1 },
      { b: 3, h: -3 },
      { b: 4, v: -1 },
      { b: 5, h: 1 },
      { b: 6, v: -3 },
      { b: 5, h: -1 },
      { b: 4, v: 1 },
      { b: 3, h: 3 },
      { b: 6, v: -1 },
      { b: 2, v: -1 },
      { h: 2 },
      { b: 1, v: -3 },
      { b: 5, h: -2 },
      { b: 9, h: -2 },
      { b: 8, h: -3 },
      { b: 4, v: 2 },
      { b: 10, v: 2 },
      { h: 2 },
    ]
    const guides = [
      [5, 2, 0, 2, -1],
      [3, 5, 3, 0, 1],
      [2, 5, 0, 1, 1],
      [2, 3, 2, 0, 1],
      [1, 3, 0, 3, 1],
      [0, 0, 0, 1, -1],
      [0, 2, 2, 0, -1],
      [3, 2, 0, 1, 1],
      [1, 0, 3, 0, -1],
      [4, 0, 0, 1, -1],
      [4, 3, 1, 0, 1],
      [2, 1, 0, 3, -1],
      [2, 3, 1, 0, -1],
      [4, 3, 0, 1, 1],
      [3, 0, 3, 0, 1],
      [2, 0, 0, 1, -1],
      [3, 0, 0, 1, -1],
      [2, 2, 2, 0, 1],
      [1, 0, 0, 3, -1],
      [0, 3, 2, 0, -1],
      [1, 4, 2, 0, -1],
      [1, 5, 3, 0, -1],
      [4, 4, 0, 2, 1],
      [5, 4, 0, 2, 1],
      [4, 2, 2, 0, 1],
    ]
    let step = 0
    const blockSize = 600 / 6
    updateSteps()
    draw()
    function onPreviousClicked() {
      step -= 1
      if (step < 0)
        step = 0
      else {
        previousOperation()
        draw()
      }
    }
    function onNextClicked() {
      step += 1
      if (step > operations.length)
        step = operations.length
      else {
        nextOperation()
        draw()
      }
    }
    function previousOperation() {
      const operation = inverseOperation(operations[step])
      applyOperation(operation)
      updateSteps()
    }
    function nextOperation() {
      applyOperation(operations[step - 1])
      updateSteps()
    }
    function updateSteps() {
      stepsEl.textContent = `${step}/${operations.length}`
    }
    function applyOperation(operation) {
      const block = operation.b === undefined ? key : blocks[operation.b]
      if (operation.h) block.p[0] += operation.h
      if (operation.v) block.p[1] += operation.v
    }
    function inverseOperation(operation) {
      return { ...operation, h: -operation.h, v: -operation.v }
    }
    function draw() {
      checkControllerState()
      clearCanvas()
      drawBlocks()
      drawGuides()
      drawKey()
    }
    function disableIf(element, condition) {
      condition ?
        element.setAttribute('disabled', '') :
        element.removeAttribute('disabled')
    }
    function checkControllerState() {
      disableIf(previousEl, step === 0)
      disableIf(nextEl, step === operations.length)
    }
    function clearCanvas() {
      canvas.clearRect(0, 0, canvasEl.width, canvasEl.height)
    }
    function toCanvasCoord(block) {
      return [
        block.p[0] * blockSize,
        block.p[1] * blockSize,
        block.h * blockSize,
        block.v * blockSize,
      ]
    }
    function textCoord(text, x, y, h, v) {
      return [
        x + h / 2 - ((text.length > 1) ? 25 : 10),
        y + v / 2 + 15,
      ]
    }
    function drawKey() {
      canvas.beginPath()
      const [x, y, h, v] = toCanvasCoord(key)
      canvas.fillStyle = 'yellow'
      canvas.fillRect(x, y, h, v)
      canvas.rect(x, y, h, v)
      canvas.stroke()
    }
    function drawBlocks() {
      canvas.beginPath()
      let index = 0
      blocks.forEach(block => {
        const [x, y, h, v] = toCanvasCoord(block)
        canvas.fillStyle = (v > h) ? 'red' : 'green'
        canvas.fillRect(x, y, h, v)

        canvas.rect(x, y, h, v)

        const i = index.toString()
        const [tx, ty] = textCoord(i, x, y, h, v)
        canvas.font = '3em Arial'
        canvas.fillStyle = 'black'
        canvas.fillText(i, tx, ty)

        index += 1
      })
      canvas.stroke()
    }
    function drawGuides() {
      const guide = guides[step]
      if (!guide)
        return
      const x = guide[0]
      const y = guide[1]
      const h = guide[2]
      const v = guide[3]
      const p = guide[4]
      canvas.beginPath()
      if (h !== 0) {
        const text = p === 1 ? '>' : '<'
        for (let i = 0; i < h; i += 1)
          drawGuide(x + i, y, text)
      }
      if (v !== 0) {
        const text = p === 1 ? '˅' : '˄'
        for (let i = 0; i < v; i += 1)
          drawGuide(x, y + i, text)
      }
      canvas.stroke()
    }
    function drawGuide(xx, yy, text) {
      const [x, y, h, v] = toCanvasCoord({ p: [xx, yy], h: 1, v: 1 })
      canvas.fillStyle = 'lightgray'
      canvas.fillRect(x, y, h, v)

      const [tx, ty] = textCoord(text, x, y, h, v)
      canvas.font = '3em Arial'
      canvas.fillStyle = 'yellow'
      canvas.fillText(text, tx, ty)
    }
  </script>
</body>

</html>
